<?php

/**
 * @file
 * Code for the Nexteuropa communities feature.
 */

include_once 'nexteuropa_communities.features.inc';

/**
 * Implements hook_block_view_alter().
 */
function nexteuropa_communities_block_view_alter(&$data, $block) {
  if ($block->delta == 'menu-community-menu') {
    $context = og_context();
    if (isset($context['gid'])) {
      $node = node_load($context['gid']);
      $data['subject'] = $node->title;
    }
    else {
      $data['content'] = array();
    }
  }
}

/**
 * Implements hook_menu().
 */
function nexteuropa_communities_menu() {
  $items['admin/config/group/context/negotiation'] = array(
    'title' => 'NextEuropa negotiation',
    'description' => 'Configure the NextEuropa context negotiation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nexteuropa_communities_configure_form'),
    'access arguments' => array('administer group'),
  );
  $items['admin/config/group/nexteuropa_private_area'] = array(
    'title' => 'NextEuropa private area',
    'description' => 'Configure the NextEuropa private area',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nexteuropa_communities_private_area_form'),
    'access arguments' => array('administer group'),
  );
  return $items;
}

/**
 * Provide a form for the nexteuropa og context negociation.
 */
function nexteuropa_communities_configure_form() {
  $form['nexteuropa_communities_url_keyword'] = [
    '#type' => 'textfield',
    '#title' => 'The url keyword for community detection',
    '#default_value' => variable_get('nexteuropa_communities_url_keyword', 'community'),
  ];
  return system_settings_form($form);
}

/**
 * Provide a form for the private area setting.
 */
function nexteuropa_communities_private_area_form() {
  $form['nexteuropa_communities_private_area'] = [
    '#type' => 'checkbox',
    '#title' => 'Enable the private area management for the community part.',
    '#default_value' => variable_get('nexteuropa_communities_private_area', FALSE),
  ];
  return system_settings_form($form);
}

/**
 * Add a new context negotiation to manage the NextEuropa communities.
 *
 * Implements hook_og_context_negotiation_info().
 */
function nexteuropa_communities_og_context_negotiation_info() {
  $providers = [];

  $providers['nexteuropa_communities'] = [
    'name' => t('NextEuropa URL'),
    'description' => t("Select group context for any url that start with the configured word, defaults at 'community'"),
    'callback' => 'nexteuropa_communities_context_handler',
  ];

  return $providers;
}

/**
 * Context handler, get the context from the URL.
 */
function nexteuropa_communities_context_handler() {
  global $language;

  $keyword = variable_get('nexteuropa_communities_url_keyword', 'community');

  // Use the NextEuropa language split for the url to remove language suffix.
  $path = nexteuropa_multilingual_language_negotiation_split_suffix(request_path(), [$language]);
  $path_args = explode('/', $path[1]);

  // Look for the community keyword in the path.
  if ($path_args[0] === $keyword) {
    $community_path = drupal_lookup_path('source', $path_args[0] . '/' . $path_args[1], $language->language);
    // If no path was found, then it's not a community in particular.
    if ($community_path !== FALSE) {
      $community_path = explode('/', $community_path);

      // Check that the node acts as a group.
      $node = node_load($community_path[1]);
      if (og_is_group('node', $node)) {
        return [
          'gid' => $node->nid,
          'group_type' => 'node',
        ];
      }
    }
  }
  return [];
}

/**
 * Implements hook_token_info().
 */
function nexteuropa_communities_token_info() {
  $info = [];

  $info['tokens']['site']['nexteuropa_communities_keyword'] = [
    'name' => t('NextEuropa Communities keyword'),
    'description' => t('A token showing the url keyword triggering the community context detection.'),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 */
function nexteuropa_communities_tokens($type, $tokens, $data, $options) {
  $replacements = [];

  switch ($type) {
    case 'site':
      foreach ($tokens as $name => $token) {
        switch ($name) {
          case 'nexteuropa_communities_keyword':
            $replacements[$token] = variable_get('nexteuropa_communities_url_keyword', 'community');;
            break;
        }
      }
      break;
  }

  return $replacements;
}

/**
 * Implements hook_permission().
 */
function nexteuropa_communities_permission() {
  return array(
    'access private area' => array(
      'title' => t('Access private area'),
      'description' => t('Allow to access to the private area.'),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function nexteuropa_communities_node_access($node, $op, $account) {
  if ($op != 'view') {
    return;
  }

  if (variable_get('nexteuropa_communities_private_area', FALSE)) {
    // The private area option is enabled.
    // DENY access only on public contents,
    // when the user has not the "access private area" permission.
    $wrapper = entity_metadata_wrapper('node', $node);

    // The node is a group.
    if (!empty($wrapper->{OG_ACCESS_FIELD}) && $wrapper->{OG_ACCESS_FIELD}->value() == 0 && og_is_group('node', $node) && !user_access("access private area", $account)) {
      return NODE_ACCESS_DENY;
    }

    // The node is a group content.
    if (!empty($wrapper->{OG_CONTENT_ACCESS_FIELD}) && !user_access("access private area", $account)) {
      $content_access = !empty($wrapper->{OG_CONTENT_ACCESS_FIELD}) ? $wrapper->{OG_CONTENT_ACCESS_FIELD}->value() : OG_CONTENT_ACCESS_DEFAULT;
      switch ($content_access) {

        case OG_CONTENT_ACCESS_PUBLIC:
          return NODE_ACCESS_DENY;

        case OG_CONTENT_ACCESS_DEFAULT:
          if (!$entity_groups = og_get_entity_groups('node', $node)) {
            break;
          }
          foreach ($entity_groups as $group_type => $values) {
            entity_load($group_type, $values);
            foreach ($values as $gid) {
              $group_wrapper = entity_metadata_wrapper($group_type, $gid);
              if (!empty($group_wrapper->{OG_ACCESS_FIELD}) && $group_wrapper->{OG_ACCESS_FIELD}->value() == 0) {
                return NODE_ACCESS_DENY;
              }
            }
          }
          break;
      }
    }
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Load a community from an URL wildcard.
 *
 * @param string $arg
 *   The name or nid of the community to load.
 *
 * @return stdClass | string
 *   Return the instance of a community, or
 */
function community_load($arg) {
  global $language;

  // If a numerical parameter was given, try do load the group directly.
  if (is_numeric($arg)) {
    $group = node_load((int) $arg);
  }
  else {
    // Get real path to get node id.
    $keyword = variable_get('nexteuropa_communities_url_keyword', 'community');
    $path = drupal_lookup_path('source', $keyword . '/' . $arg, $language->language);

    if ($path === FALSE) {
      return NULL;
    }

    // Get the nid and load the group.
    $path = explode("/", $path);

    // Stop the search if the url is not of type 'node/nid'.
    if ($path[0] !== 'node' || !is_numeric($path[1])) {
      return NULL;
    }

    $group = node_load($path[1]);
  }

  // Check if the loaded content is an OG Group.
  if ($group !== FALSE && og_is_group('node', $group)) {
    return $group;
  }

  // If no group was found, pass the argument as is.
  return NULL;
}
